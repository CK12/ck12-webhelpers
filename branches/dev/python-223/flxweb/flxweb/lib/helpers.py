#
# Copyright 2007-2011 CK-12 Foundation
#
# All rights reserved
#
#
# Unless required by applicable law or agreed to in writing, software
# distributed under this License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied.  See the License for the specific language governing
# permissions and limitations.
#
# This file originally written by Ravi Gidwani
#
# $Id$


"""
Helper functions

Consists of functions typically to be used within templates, but also
available to Controllers. This module is available to templates as 'h'.
"""
# Import helpers as desired, or define your own, ie:
#from webhelpers.html.tags import checkbox, password
from routes import url_for
from pylons import url as _url, request, config, tmpl_context as c
# Used in templates with h.<name>
from flxweb.lib.ck12.url_helpers import url_cdn, url_css, url_images, url_js, url_lib, url_assessment
# Used in new foundation based templates with h.<name>
from flxweb.lib.ck12.url_helpers import asset_js,asset_lib,asset_css,asset_image
from datetime import datetime
import urllib
from flxweb.model.gdtimport import GDTImporter
from webhelpers.html import HTML, tags, builder
import logging
import urlparse

log = logging.getLogger(__name__)

def url(*args, **kwargs):
    if args and len(args) > 0:
        return unicode(_url(args[0].encode('utf-8'),**kwargs),'utf-8')
    else:
        return _url(*args,**kwargs)

def genURLSafeBase64Encode(string, strip=True):
    """ Returns a URL-safe Base64 encode of the string with '=' replaced with
    '_' after the encode. """
    from base64 import urlsafe_b64encode
    if strip:
        string = string.strip()
    if not isinstance(string, str):
        string = string.encode('utf-8')
    return urlsafe_b64encode(string).replace('=', '.')

def genURLSafeBase64Decode(encoded_string):
    """ Returns the decoded string of the base64 encode generated by
    genURLSafeBase64Encode function. """
    from base64 import urlsafe_b64decode
    if not isinstance(encoded_string, str):
        encoded_string = encoded_string.encode('utf-8')
    return urlsafe_b64decode(encoded_string.replace('.', '='))


def convertTime(timestamp):
    if isinstance(timestamp, str) or isinstance(timestamp, unicode):
        # String timestamp should be in iso time format like '2012-04-26 13:36:20'
        time = datetime.strptime(timestamp,"%Y-%m-%d %H:%M:%S")
    if isinstance(timestamp, dict):
        time = datetime(timestamp['year'], timestamp['month'], timestamp['day'], timestamp['hour'], timestamp['min'] )
    now = datetime.now()
    timedict = {}
    timedict['format'] = 'date'
    if time.day == now.day:
        timedict['format'] = 'time'
        timedict['time'] = time.strftime('%I:%M %p').lower()
    elif time.year == now.year:
        timedict['time'] = time.strftime('%b')+' '+ str(time.day)
    else:
        #TODO:localization
        timedict['time'] = time.strftime("%m/%d/%y")
    return  timedict

def get_chunked_list(given_list, chunk_size):
    return list(_get_chunks(given_list, chunk_size))

def _get_chunks(given_list, chunk_size):
    for i in xrange(0, len(given_list), chunk_size):
        yield given_list[i:i+chunk_size]

def safe_encode(s):
    if s and type(s).__name__ == 'unicode':
        return s.encode('utf-8')
    return s

def safe_decode(s):
    if s and type(s).__name__ == 'str':
        return s.decode('utf-8')
    return s

def auth_signin_url(popup=False,hash=False):
    '''
    Returns the signin url pointing to the auth service.
    Add the requestor and returnTo parameters
    '''
    auth_url = url('auth-signin')
    request_url = None
    if request.path and 'error/document' not in request.path:
        request_url = request.url
    else:
        request_url = url('dashboard',qualified=True)

    if popup:
        authorized_url = url('authorized_popup',qualified=True)
        final_url = '%s?popup=true' % (auth_url)
    else:
        authorized_url = url('authorized',qualified=True)
        final_url = '%s?' % (auth_url)
    final_url = '%s&requestor=%s&returnTo=%s' % (final_url, urllib.quote(request_url),urllib.quote(authorized_url))
    if request_url:
        # remove the s=signed_out query parameter is present,we use that just to track the
        # signed out state
        r_url = request_url.replace('s=signed_out','')
        # need to double quote to make sure the url gets propogated to auth service
        next_url = urllib.quote(urllib.quote(r_url.encode('utf-8')))
        final_url = '%s?next=%s' % (final_url,next_url)

    #Add a placeholder for the hash fragment. This placeholder gets
    #replaced by JS (from auth_redirect.html) before the page gets
    #redirected to the auth service. We need this to make sure we
    #can maintain the hash fragments between flxweb and auth service page transition.
    if (not popup) and hash:
        final_url = '%s___HASH___' % ( final_url)
    return final_url

def auth_signup_url(extra_qs=None, teacher=False):
    '''
    Returns the signin url pointing to the auth service.
    Add the requestor and returnTo parameters
    '''
    auth_signup = url('auth-signup')
    requestor = request.url
    returnTo = request.url
    role_cookie = request.cookies.get('flxweb_role')
    if '/student/' in request.path or '/features' in request.path or request.path == '/':
        returnTo = url('dashboard',qualified=True)
    if teacher or '/teacher/' in request.path:
        auth_signup = '%s/teacher' % auth_signup
        returnTo = url('dashboard_new',qualified=True)
    else:
        auth_signup = '%s/student' % auth_signup
    auth_signup = '%s?requestor=%s&returnTo=%s' % ( auth_signup, urllib.quote(requestor),urllib.quote(returnTo))
    if extra_qs:
        auth_signup = '%s&%s' % (auth_signup, extra_qs)

    return auth_signup

def answer_keys_url():
    '''
    Returns the url for the google form used for capturing
    the TE answer keys requests.
    '''
    google_form_url = config.get('answer_keys_url')
    if request and request.url:
        google_form_url = google_form_url.replace('$URL$',urllib.quote(request.url))
    else:
        google_form_url = google_form_url.replace('$URL$','')

    if c.user:
        google_form_url = google_form_url.replace('$EMAIL$',urllib.quote(c.user['email']))
        google_form_url = google_form_url.replace('$NAME$',urllib.quote(safe_encode(c.user['fullName'])))
    else:
        google_form_url = google_form_url.replace('$EMAIL$','')
        google_form_url = google_form_url.replace('$NAME$','')
    return google_form_url

def resourceNameToHandle(name):
        if name:
            return name.rstrip('/').replace(' ', '-')
        return name

def htmldiv(txt=None, id=None, class_=None):
    return HTML.tag('div', c=txt, id=id, class_=class_)

def _is_branch_invalid(branch):
    if branch and branch.slug() in ['science','mathematics']:
        return True
    return False

def artifact_url(artifact, revisioned=False):
    perma = ''
    if artifact.get('isModality') == 1:
        domain = artifact.get('domain',{})
        domain = {} if not domain else domain
        branch_eid = artifact.get_branch_encodedid()
        branch = None
        # Get the branch details if it is not a UGC branch
        if branch_eid and not branch_eid.startswith('UGC'):
            from flxweb.model.browseTerm import BrowseTerm
            try:
                branch = BrowseTerm(domain).get_branch()
            except Exception, e:
                log.exception('Browse Term for branch EID "%s" is not found for type "%s" with handle "%s"' % (branch_eid,artifact.get('artifactType'),domain.get('handle')))
        realm = artifact.get('realm')
        artifact_revision = artifact.getVersionNumber()

        if artifact.get('collections'):
            branch['name'] =  artifact.get('collections')[0].get('collectionHandle')
            domain['handle'] = artifact.get('collections')[0].get('conceptCollectionAbsoluteHandle')

        # If there is no domain information serve the old UI.
        # NOTE: This should ideally not be the case for a modality.
        # Each modality will have a concept or a dummy (aka ghost)
        # node. But adding this case here for safety

        if not domain or _is_branch_invalid(branch):
            if artifact_revision :
                ext_rev = 'r%s' % artifact_revision
            else:
                ext_rev= None
            if artifact_revision:
                ext_rev = 'r%s' % artifact_revision
            else:
                ext_rev= None
            perma = url(controller='details', action='artifact_perma',
                        artifact_type='lesson',
                        artifact_title=artifact.get('handle'),
                        realm=realm,
                        ext=ext_rev)
        elif not branch and not realm:
            if revisioned and artifact_revision:
                perma  = url('modality_ext',
                              handle=domain.get('handle'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              ext='r%s' % artifact_revision,
                              qualified=True)
            else:
                perma  = url('modality',
                              handle=domain.get('handle'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              qualified=True)
        elif (not branch) and realm:
            if revisioned and artifact_revision:
                perma = url('modality_realm_ext',
                              handle=domain.get('handle'),
                              realm=artifact.get('realm'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              ext='r%s' % artifact_revision,
                              qualified=True)
            else:
                if revisioned and artifact_revision:
                    perma = url('modality_realm_ext',
                                  handle=domain.get('handle'),
                                  realm=artifact.get('realm'),
                                  mtype=artifact.get('artifactType'),
                                  mhandle=artifact.get('handle'),
                                  ext='r%s' % artifact_revision,
                                  qualified=True)

                else:
                    perma = url('modality_realm',
                                  handle=domain.get('handle'),
                                  realm=artifact.get('realm'),
                                  mtype=artifact.get('artifactType'),
                                  mhandle=artifact.get('handle'),
                                  qualified=True)
        elif not realm:
            if revisioned and artifact_revision:
                perma = url('modality_branch_ext',
                              branch=branch.slug(),
                              handle=domain.get('handle'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              ext='r%s' % artifact_revision,
                              qualified=True)
            else:
                perma = url('modality_branch',
                              branch=branch.slug(),
                              handle=domain.get('handle'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              qualified=True)
        else:
            if revisioned and artifact_revision:
                perma = url('modality_branch_realm_ext',branch=branch.slug(),
                              handle=domain.get('handle'),
                              realm=artifact.get('realm'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              ext='r%s' % artifact_revision,
                              qualified=True)
            else:
                perma = url('modality_branch_realm',branch=branch.slug(),
                              handle=domain.get('handle'),
                              realm=artifact.get('realm'),
                              mtype=artifact.get('artifactType'),
                              mhandle=artifact.get('handle'),
                              qualified=True)
        log.debug('perma in artifact_url %s' %(perma))


        if artifact.get('collections'):
            url_details =  urlparse.urlparse(perma)
            perma = '%s://%s/c%s' % (url_details.scheme, url_details.netloc, url_details.path)
            log.debug('perma in artifact_url  in conllection %s' %(perma))
    else:
        perma = url(artifact.getPermaHandle(include_version=revisioned),qualified=True)
    return perma

def calculate_processing_time(start_time):
    end_time = datetime.now()
    timedelta = end_time -start_time
    return '%s.%s' % (timedelta.seconds, timedelta.microseconds)

def getGoogleAuthURL():
    """
    Get the Google autherization URL.
    """
    return GDTImporter.getGoogleAuthURL()

def unquote(str):
    if(str):
        return safe_decode(urllib.unquote(safe_encode(str)))
    return str

def getDomainEIDFromEID(encodedID):
    if encodedID:
        parts = encodedID.split('.')
        if len(parts) == 6:
            encodedID = '.'.join(parts[:-2])
        elif len(parts) == 5:
            if parts[-1].isalpha():
                encodedID = '.'.join(parts[:-1])
            else:
                encodedID = '.'.join(parts[:-2])
        elif len(parts) == 4:
            if parts[-1].isalpha():
                encodedID = '.'.join(parts[:-1])
    return encodedID

def canonical_url():
    '''
    Canonical URL for book and modality URLs
    It just removes the revision information from the URL
    '''
    page_url_canonical = None

    if request.path:
        page_url_canonical = request.path
        try:
            import re
            #Piviotal Story #141361579 Make first part of path all lowercase
            tolower = re.match(r"^/((\w+)|(\w+[-']\w*))/", request.path)
            if tolower:
                page_url_canonical = page_url_canonical.replace(tolower.group(1),tolower.group(1).lower())
            m = re.search(r'/r\d+/?', request.path)
            if m:
                page_url_canonical = request.path.replace(m.group(0),'/')
            #page_url_canonical = url(page_url_canonical,qualified=True)
            # FN: Site will support full https.
            # Set protocol to https for canonical urls.
            if page_url_canonical[:3] == '/c/':
                page_url_canonical = None
            else:
                page_url_canonical = 'https://www.ck12.org' + page_url_canonical
        except Exception,e:
            log.exception(e)
            page_url_canonical = None
    return page_url_canonical

def get_substring(string, start, end):
    return string[start:end]

def slugify(name):
    return name.replace(' ', '-').lower()

def external_domains():
    """
    Returns the list of external domains used on pages.
    We use this list to prefetch the DNS
    """
    domains = []
    cdn_api_cache = config.get('cdn_api_cache')
    cdn_enabled = config.get('cdn_enabled')

    if (cdn_enabled == "true"):
        static_domains = config.get('static_cdn_locations').split(',')
        img_domains = config.get('img_cdn_locations').split(',')

        for item in static_domains:
            item = item.strip(' ')
            if item not in domains:
                domains.append(item)

        for item in img_domains:
            item = item.strip(' ')
            if item not in domains:
                domains.append(item)

    if cdn_api_cache:
        domains.append("//%s" % cdn_api_cache.strip(' '))
    return domains
