import time
import logging
import logging.handlers
import subprocess
import os
from tempfile import NamedTemporaryFile

"""Helper functions"""

verticalSpaceRaw = u'\xa0'
verticalSpaceIntmRaw = 'INTERIM_VERTICAL_SPACER'
verticalSpaceP = '<p>&nbsp;</p>'
verticalSpaceIntmP = '<p>%s</p>' % verticalSpaceIntmRaw
css_file_identifier = 'STYLE_CSS_FILE_PATH'
POUND_SIGN_TEXT = 'POUND_SIGN'

color_class_codes = {
                      'aqua'   : '#00FFFF',
                      'black'  : '#000000',
                      'blue'   : '#0000FF',
                      'fuchsia': '#FF00FF',
                      'gray'   : '#808080',
                      'grey'   : '#808080',
                      'green'  : '#008000',
                      'lime'   : '#00FF00',
                      'maroon' : '#800000',
                      'navy'   : '#000080',
                      'olive'  : '#808000',
                      'purple' : '#800080',
                      'red'    : '#FF0000',
                      'silver' : '#C0C0C0',
                      'teal'   : '#008080',
                      'white'  : '#FFFFFF',
                      'yellow' : '#FFFF00'
                    }

textbgcolor_style_skeleton = "\n.x-ck12-textbgcolor-%s {\n \
                              background-color : %s;\n \
                              overflow : auto;\n \
                         }\n\n"

textcolor_style_skeleton = "\n.x-ck12-textcolor-%s {\n \
                              color : %s;\n \
                         }\n\n"

elementbox_style = ".x-ck12-element-box {\n \
     border: 1px solid black;\n \
     background-color: #DDDDFF;\n \
  }\n\n \
  .x-ck12-element-box-header {\n \
     background-color:lightBlue;\n \
     border-bottom: 1px solid black;\n \
     padding: 5px;\n \
  }\n\n \
  .x-ck12-element-box-body {\n \
     padding: 5px;\n \
  }\n\n"

try:
    LOG_FILENAME = "process.log"
    log = logging.getLogger(__name__)
    log.setLevel(logging.DEBUG)
    handler = logging.handlers.RotatingFileHandler(LOG_FILENAME, maxBytes=10*1024*1024, backupCount=5)
    log.addHandler(handler)
except:
    pass

def genURLSafeBase64Encode(string, strip=True, usePrefix=True):
    """ Returns a URL-safe Base64 encode of the string with '=' replaced with
    '_' after the encode. """
    if not string:
        return string
    from base64 import urlsafe_b64encode
    if strip:
        string = string.strip()
    if not isinstance(string, str):
        string = string.encode('utf-8')
    string = urlsafe_b64encode(string).replace('=', '.')
    if usePrefix:
        string = 'x-ck12-%s' % string
    return string

def genURLSafeBase64Decode(encoded_string, hasPrefix=True):
    """ Returns the decoded string of the base64 encode generated by
    genURLSafeBase64Encode function. """
    if not encoded_string:
        return encoded_string
    from base64 import urlsafe_b64decode
    if hasPrefix:
        encoded_string = encoded_string.replace('x-ck12-','')
    if not isinstance(encoded_string, str):
        encoded_string = encoded_string.encode('utf-8')
    return urlsafe_b64decode(encoded_string.replace('.', '='))

def convert_html_entitities(encoded_string):
    import re
    return re.sub('&#(\d+);', lambda matchObj: unichr(int(matchObj.group(1))), encoded_string)

def convert_strip_dictionary(dictionary):
    for eachKey in dictionary.keys():
        dictionary[eachKey] = convert_html_entitities(dictionary[eachKey]).strip()
    return dictionary

def get_textbgcolor_styles():

    styles = ''

    for color_class,color_code in color_class_codes.items():
        styles = styles + textbgcolor_style_skeleton % (color_class,color_code)

    return styles

def get_textcolor_styles():

    styles = ''

    for color_class,color_code in color_class_codes.items():
        styles = styles + textcolor_style_skeleton % (color_class,color_code)

    return styles

def clear_dictionary(dictionary, keys):
    for eachKey in keys:
        if not dictionary[eachKey]:
            value = dictionary.pop(eachKey)
    return dictionary

class ProcessWithTimeout(object):
    """
        A wrapper around the subprocess module to allow killing the process after a timeout.
    """

    def __init__(self, cmd, cwd=None):
        self.cmd = cmd
        self.cwd = cwd
        self.proc = None
        self.output = None
        self.error = None

    def start(self, timeout=300):
        outputFile = None
        errorFile = None
        try:
            outputFile = NamedTemporaryFile(suffix=".out", delete=False)
            errorFile = NamedTemporaryFile(suffix=".err", delete=False)

            log.info("output: %s" % outputFile.name)
            log.info("error: %s" % errorFile.name)

            timeSpent = 0
            self.proc = subprocess.Popen(self.cmd, stdin=None,
                                         stdout=outputFile, stderr=errorFile,
                                         cwd=self.cwd, shell=True)
            if timeout:
                while True:
                    time.sleep(1)
                    self.proc.poll()
                    if self.proc.returncode is not None:
                        break
                    timeSpent += 1
                    if timeSpent > timeout:
                        log.warning('Killing process because the timeout of %d seconds was exceeded.' % timeout)
                        self.proc.terminate()
                        self.proc.kill()
                        break
            else:
                self.proc.wait()

            outputFile.close()
            errorFile.close()

            if os.path.exists(outputFile.name):
                self.output = open(outputFile.name, "r").read()
                log.info("Output: %s" % self.output)

            if self.proc.returncode != 0:
                self.error = open(errorFile.name, "r").read()
                log.error("Process failed with code: %s" %(self.proc.returncode if self.proc.returncode else "process was terminated"))
                log.error("ERROR: %s" % self.error)
                return self.proc.returncode
            else:
                log.info("Process succeeded with returncode: %d" % self.proc.returncode)
                return 0
        finally:
            try:
                if outputFile:
                    outputFile.close()
                if errorFile:
                    errorFile.close()
            finally:
                if os.path.exists(errorFile.name):
                    os.remove(errorFile.name)
                if os.path.exists(outputFile.name):
                    os.remove(outputFile.name)

def getRandomString(noOfChars):
    import string
    import random
    allChars = [x for x in string.lowercase] + [x for x in string.lowercase] + [x for x in string.digits]
    random.shuffle(allChars)
    return "".join(allChars[:noOfChars])
