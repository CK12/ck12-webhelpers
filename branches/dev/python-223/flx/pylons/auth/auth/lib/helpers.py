"""Helper functions

Consists of functions to typically be used within templates, but also
available to Controllers. This module is available to templates as 'h'.
"""
# Import helpers as desired, or define your own, ie:
#from webhelpers.html.tags import checkbox, password
from pylons.i18n.translation import _ 
import os
import logging
from tempfile import NamedTemporaryFile
from datetime import datetime, date, time as tm
from decimal import Decimal
from pylons import config
from pylons import url as _url
from urllib import quote, unquote
import time
import hashlib
import shutil
import socket
import stat
import tempfile
import binascii
import re,json
## Following imports are used in templates - DO NOT REMOVE
from auth.lib.ck12.url_helpers import url_cdn, url_css, url_images, url_js, url_lib
from auth.lib.localtime import Local

log = logging.getLogger(__name__)

def processInstantNotifications(eventIDs, notificationIDs=None, user=None, noWait=False):
    """
        Process any instance notifications for this event
    """
    from auth.controllers.celerytasks import notifier
    log.info("eventIDs: %s, notificationIDs: %s" % (eventIDs, notificationIDs))
    if eventIDs:
        if noWait:
            log.info("No wait: %s, processing notification right away." % str(noWait))
            n = notifier.QuickEmailNotifierTask()
            ret = n.apply(kwargs={'eventIDs': eventIDs, 'notificationIDs':notificationIDs, 'user': user, 'loglevel': 'INFO'})
            log.info("Called task: %s" % ret)
            return ret.result
        else:
            n = notifier.EmailNotifierTask()
            t = n.delay(eventIDs=eventIDs, notificationIDs=notificationIDs, loglevel='INFO', user=user)
            return t.task_id
    return None

def genMD5Hash(path):
    f = open(path, 'rb')
    m = hashlib.md5()
    try:
        bufSize = 4096
        c = f.read(bufSize)
        while len(c) > 0:
            m.update(c)
            c = f.read(bufSize)
    finally:
        f.close()
    return m.hexdigest()


def encrypt(string, settings, default_iv=False):
    from auth.lib.cryptor import Cryptor
    if not (isinstance(string,str) or isinstance(string,unicode)):
        string = json.dumps(string)
    string = safe_encode(string)
    key = settings.get('aes_secret_key')
    if not key:
        raise Exception("No secret key found in the settings")
    block_size = int(settings.get('aes_block_size', 16))
    cryptor = Cryptor(key,block_size=block_size, default_iv=default_iv)
    iv, encrypted = cryptor.encrypt(string, in_key=key)
    #log.info('IV: %s \nencryped: %s' % (iv, binascii.b2a_base64(encrypted).rstrip()))
    if default_iv:
        encrypted = binascii.b2a_base64(encrypted).rstrip()
    else:
        # Cf no default iv, combine both iv(random) and cypher text in a single string.
        # Check the 'decrypt' module for how to split the strings again.
        encrypted = binascii.b2a_base64(iv).rstrip()+binascii.b2a_base64(encrypted).rstrip()
    return encrypted

def decrypt(cipher, settings, default_iv=False):
    from auth.lib.cryptor import Cryptor
    key = settings.get('aes_secret_key')
    if not key:
        raise Exception("No secret key found in the settings")
    block_size = int(settings.get('aes_block_size', 16))
    if default_iv:
       in_iv= None
       encrypted = cipher
    else:
        # The cipher has both IV, and encrypted data seperated with "="
        splits = cipher.split("=",1)
        iv=splits[0]+"="
        in_iv = binascii.a2b_base64(iv)
        #log.info("IV %s" % in_iv)
        encrypted=splits[1]
    cryptor = Cryptor(key,block_size=block_size, default_iv=default_iv)
    string = cryptor.decrypt(encrypted, in_key=key, in_iv=in_iv)
    #log.info('Decrypted string %s' % string)
    return string


def genURLSafeBase64Encode(string, strip=True, usePrefix=True):
    """ Returns a URL-safe Base64 encode of the string with '=' replaced with
    '_' after the encode. """
    if not string:
        return string
    from base64 import urlsafe_b64encode
    if strip:
        string = string.strip()
    if not isinstance(string, str):
        string = string.encode('utf-8')
    string = urlsafe_b64encode(string).replace('=', '.')
    if usePrefix:
        string = 'x-ck12-%s' % string
    return string

def genURLSafeBase64Decode(encoded_string, hasPrefix=True):
    """ Returns the decoded string of the base64 encode generated by
    genURLSafeBase64Encode function. """
    if not encoded_string:
        return encoded_string
    from base64 import urlsafe_b64decode
    if hasPrefix:
        encoded_string = encoded_string.replace('x-ck12-','')
    if not isinstance(encoded_string, str):
        encoded_string = encoded_string.encode('utf-8')
    return urlsafe_b64decode(encoded_string.replace('.', '='))

def load_pylons_config(test_mode=False):
    """
        Loads some parts of pylons configuration for modules outside pylons
    """
    ## Get the production.ini file path
    mydir = os.path.dirname(os.path.abspath(__file__))
    for i in range(1, 3):
        mydir = os.path.dirname(mydir)
    CONFIG_FILE = os.path.join(mydir, "production.ini")

    import ConfigParser

    cfg = ConfigParser.ConfigParser()
    DEV_CONFIG_FILE = CONFIG_FILE.replace('production.ini', 'development.ini')
    if os.path.exists(CONFIG_FILE):
        cfg.read(CONFIG_FILE)
    elif os.path.exists(DEV_CONFIG_FILE):
        cfg.read(DEV_CONFIG_FILE)
    elif os.path.exists('/opt/2.0/flx/pylons/auth/production.ini'):
        cfg.read('/opt/2.0/flx/pylons/auth/production.ini')
    elif os.path.exists('/opt/2.0/flx/pylons/auth/development.ini'):
        cfg.read('/opt/2.0/flx/pylons/auth/development.ini')
    else:
        raise Exception((_(u"Cannot find %(CONFIG_FILE)s or %(DEV_CONFIG_FILE)s")  % {"CONFIG_FILE":CONFIG_FILE,"DEV_CONFIG_FILE": DEV_CONFIG_FILE}).encode("utf-8"))


    configs = [cfg]
    if test_mode:
        test_cfg = ConfigParser.ConfigParser()
        if os.path.exists(CONFIG_FILE):
            TEST_CONFIG_FILE = CONFIG_FILE.replace('production.ini', 'test.ini')
        else:
            TEST_CONFIG_FILE = "/opt/2.0/flx/pylons/auth/test.ini"
        if os.path.exists(TEST_CONFIG_FILE):
            test_cfg.read(TEST_CONFIG_FILE)
        configs.append(test_cfg)


    conf = {}
    for cfg in configs:
        sections = ['DEFAULT', 'app:main', 'server:main']
        for section in sections:
            for name, value in cfg.items(section):
                conf[name] = value
    return conf

def url(*args, **kwargs):
    if args and len(args) > 0:
        return unicode(_url(args[0].encode('utf-8'),**kwargs),'utf-8')

    return _url(*args,**kwargs)

class ForbiddenError(Exception):
    pass

def validateDomain(url):
    from urlparse import urlparse

    netloc = urlparse(url).netloc.lower()
    l = netloc.split(':')
    domain = l[0]
    if domain and not domain.endswith('.ck12.org') and not domain.endswith('.ck12info.org'):
        raise ForbiddenError('Forbidden to access %s' % domain)

def __getCache():
    global config
    if not config.get('cache_share_dir'):
        config = load_pylons_config()

    from beaker.cache import CacheManager

    log.info("cache_share_dir: %s" % config.get('cache_share_dir'))
    cm = CacheManager(type='file', data_dir=config.get('cache_share_dir'))
    return cm.get_cache('test-login-repo')

def internalLogin(userID):
    """
        Imitate the login by creating a cache entry for the user id along with the
        timestamp.
        Only valid for the expiration time
    """
    internalLogout(userID)
    cache = __getCache()
    ts = int(time.time() * 1000)
    val = '%s:%s' % (userID, ts)
    ret = cache.get_value(key='test-login-%s' % userID, createfunc=lambda: '%s' % (val), expiretime=30*60)
    return ret

def internalLogout(userID):
    cache = __getCache()
    cache.remove_value(key='test-login-%s' % userID)

def getLoginCookie(userID):
    val = internalLogin(userID)
    return '%s=%s' % (config.get('beaker.session.key'), val)

def safe_encode(s):
    if s and type(s).__name__ == 'unicode':
        return s.encode('utf-8')
    return s

def safe_decode(s):
    if s and type(s).__name__ == 'str':
        return s.decode('utf-8')
    return s

def encode_encrypted(s):
    try:
        return safe_decode(s)
    except:
        return s.decode('utf-8', 'ignore')

def to_unicode(obj, encode=False):
    try:
        if not isinstance( obj, basestring):
            obj = unicode(obj)
        if encode:
            obj = obj.encode('utf-8')
    except:
        pass
    return obj

def restoreSlash(url):
    if url is None:
        return url

    if '://' not in url and ':/' in url:
        return url.replace(':/', '://')

    return url

def checkUrlExists(url):
    from urllib import FancyURLopener
    class CK12Opener(FancyURLopener):
        version = 'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.124 Safari/534.31'
    opener = CK12Opener().open(url)
    if opener.getcode() >= 400:
        return False
    else:
        return True

def urlretrieve(uri, filepath):
    from urllib import FancyURLopener
    class CK12Opener(FancyURLopener):
        version = 'Mozilla/5.0 (X11; Linux i686) AppleWebKit/534.30 (KHTML, like Gecko) Chrome/12.0.742.124 Safari/534.31'
    return CK12Opener().retrieve(uri, filepath)

def getRandomString(noOfChars):
    import string
    import random
    allChars = [x for x in string.lowercase] + [x for x in string.lowercase] + [x for x in string.digits]
    random.shuffle(allChars)
    return "".join(allChars[:noOfChars])

def getConfigOptionValue(option):
    global config
    if not config or not config.has_key('instance'):
        config = load_pylons_config()
    return config.get(option)

def urlencode(params):
    out = {}
    for k, v in params.iteritems():
        if isinstance(v, unicode):
            v = v.encode('utf8')
        elif isinstance(v, str):
            v.decode('utf8')
        out[k] = v

    from urllib import urlencode as ue
    return ue(out)

def urlQuote(url):
    return quote(url)

def urlUnquote(url):
    return unquote(url)

def saveUploaded(uri, file):
    """
        Save the uploaded contents to the given file.
    """
    shutil.copyfileobj(uri.file, file)
    uri.file.close()

def saveUploadedToTemp(uri):
    """
        Save the uploaded contents to a temporary file
    """
    tempfd = NamedTemporaryFile()
    tempFile = tempfd.name
    tempfd.close()
    tempFilefd = open(tempFile, 'w')
    shutil.copyfileobj(uri.file, tempFilefd)
    tempFilefd.close()
    uri.file.seek(0, 0)
    #uri.file.close()
    return tempFile

def saveUploadedFile(request, fileParam, dir=None, allowedExtenstions=None, duplicateFile=False, userID=None):
    uploadedFile = request.POST[fileParam]
    
    file_name = safe_encode(uploadedFile.filename)
    #Bug - 12362 - For XDT requests - On windows instance subproces.Popen is not supported with unicode characters,
    #create a file with some random name and use this file to process the docx importing
    if duplicateFile:
        import random
        random_string = hashlib.md5(random.random().__str__()).hexdigest()
        if userID:
            file_name = "_%s_%s_%s"%(userID,random_string,file_name)
            tmp_file_name = "_%s_%s_%s" %(userID,random_string,str(allowedExtenstions[0]))
        else:
            tmp_file_name = "_%s_%s" %(random_string,str(allowedExtenstions[0]))

    log.info('File %s [%d bytes]' % (file_name.decode("utf-8"), len(uploadedFile.value)))
    if allowedExtenstions:
        fn = file_name.lower()
        matched = False
        for ext in allowedExtenstions:
            if fn.endswith(ext):
                matched = True
                break
        if not matched:
            raise Exception('Invalid file name extension. Allowed extensions are: %s' % ','.join(allowedExtenstions))
    try:
        ## save the file to temp location
        tfile = NamedTemporaryFile(suffix=os.path.basename(file_name), delete=False, dir=dir)
        saveUploaded(uploadedFile, tfile)
        tfile.close()
        # if xdt request then return the temp_tfile name i.e. file name with some random string
        if duplicateFile:
            temp_tfile = NamedTemporaryFile(suffix=os.path.basename(tmp_file_name), delete=False, dir=dir)
            tfile = open(tfile.name, "r")
            shutil.copyfileobj(tfile, temp_tfile)
            tfile.close()
            temp_tfile.close()
            os.chmod(temp_tfile.name, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH)
            return temp_tfile.name
            
        os.chmod(tfile.name, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH)
        return safe_decode(tfile.name)
    except Exception, e:
        log.error('Error saving uploaded file to disk: Exception[%s]' % str(e))
        raise e

def saveFileToDirectory(src, dir):
    try:
        srcfile = open(src, "rb")
        ## save the file to temp location
        tfile = NamedTemporaryFile(suffix=os.path.basename(src), delete=False, dir=dir)
        shutil.copyfileobj(srcfile, tfile)
        srcfile.close()
        tfile.close()
        os.chmod(tfile.name, stat.S_IRUSR | stat.S_IWUSR | stat.S_IRGRP | stat.S_IWGRP | stat.S_IROTH | stat.S_IWOTH)
        return tfile.name
    except Exception, e:
        log.error('Error saving uploaded file to disk: Exception[%s]' % str(e))
        raise e

def updateCleverPartnerData(wait=False, **kwargs):
    """
    """
    from auth.controllers.celerytasks import clever
    
    if wait:
        updator = clever.CleverPartnerUpdator()
        ret = updator.apply(**kwargs)
        log.info("Called CleverPartnerUpdator task : %s" % ret)
        return ret.result
    else:
        updator = clever.CleverPartnerUpdator()
        task = updator.delay(**kwargs)
        return task.task_id

def initTranslator():
    import pylons

    push = False
    if hasattr(pylons, 'translator'):
        typeName = type(pylons.translator).__name__
        log.debug('initTranslator: Found translator: %s' % typeName)
        if typeName not in [ 'NullTranslations', 'GNUTranslations', 'StackedObjectProxy' ]:
            log.debug('initTranslator: Did not find any objects of interest - pushing!')
            push = True
        elif typeName == 'StackedObjectProxy':
            found = False
            objects = None
            try:
                objects = pylons.translator._object_stack()
            except:
                pass
            if objects:
                log.debug('initTranslator: Found StackedObjectProxy: Size: %d' % len(objects))
                for obj in objects:
                    objType = obj.__class__.__name__
                    log.debug('Object: %s, Type: %s' % (obj, objType))
                    if objType in [ 'NullTranslations', 'GNUTranslations' ]:
                        log.debug('initTranslator: Found object of type: %s' % objType)
                        found = True
                        break
            push = not found
    else:
        push = True

    if push:
        #
        #  Set up i18n translator.
        #
        conf = pylons.config.current_conf()
        if not conf['pylons.paths']['root']:
            conf['pylons.paths']['root'] = os.path.abspath('/opt/2.0/flx/pylons/auth/auth')
            if os.name == 'nt':
                conf['pylons.paths']['root'] = os.path.abspath('c:/2.0/flx/pylons/auth/auth')
        if not conf.get('pylons.package'):
            conf['pylons.package'] = 'auth'
        obj = pylons.i18n.translation._get_translator('en')
        pylons.translator._push_object(obj)
        log.info('initTranslator: pushed: %s' % obj)
    log.info('initTranslator: translator[%s]' % pylons.translator)

def get_upload_dir():
    '''
    get configuration setting for resource upload directory
    defaults to system's temporary directory
        '''
    resource_upload_dir = config.get('resource_upload_dir')
    if not resource_upload_dir:
        log.warn("!!WARNING!! resource_upload_dir is not configured!")
    if not os.path.exists(resource_upload_dir):
        try:
            os.makedirs(resource_upload_dir)
        except:
            log.warn("!!WARNING!! could not create resource_upload_dir %s" % resource_upload_dir)
            resource_upload_dir = None
    return resource_upload_dir
    
def upload_dir_is_shared():
    '''
    returns whether the upload directory is shared with 
    coreapi servers using the config setting:
    resource_upload_dir_shared
    defaults to False
    '''
    shared = config.get('resource_upload_dir_shared', False)
    return shared == 'true'
    
def get_unique_upload_dir():
    try:
        uploaddir = get_upload_dir()
        if not uploaddir:
            uploaddir = tempfile.gettempdir()
        f = tempfile.NamedTemporaryFile(dir=uploaddir)
        dirname = f.name
        f.close()
        os.makedirs(dirname)
        return dirname
    except:
        raise Exception("Failed to create upload directory %s" % uploaddir)

def store_upload_file(path, filename, fileobj):
    try:
        filename = safe_encode(os.path.join(path, filename))
        storedfile = open(filename, 'w')
        shutil.copyfileobj(fileobj, storedfile)
        fileobj.close()
        storedfile.close()
        return safe_decode(filename)
    except Exception, e:
        log.error("Error copying uploaded file", exc_info=e)
        raise Exception("Failed to save uploaded file %s to %s." % (filename, path) )
    
def validate_resource_size(stored_file_path, param='profile_image_max_upload_size'):
    '''
        Check size of uploaded resource
    '''
    storedfile = None
    try:
        storedfile = open(safe_encode(stored_file_path), 'rb+')
        storedfile.seek(0,2)
        resource_size = storedfile.tell()
        max_upload_size = config.get(param)
        if (resource_size > int(max_upload_size)) :
            return False
        return True
    except Exception, ex:
        raise ex
    finally:
        if storedfile is not None:
            storedfile.close()

INPUT_SIZE = 8
 
def pad_string(str):
 
    new_str = str
    pad_chars = INPUT_SIZE - (len(str) % INPUT_SIZE)
 
    if pad_chars != 0:
        for x in range(pad_chars):
            new_str += " "
 
    return new_str

def obfuscate(s):
    return s.encode('rot13') if s else None

def deobfuscate(s):
    return s.decode('rot13') if s else None

hostname = None
def getHostname():
    global hostname
    if not hostname:
        hostname = obfuscate(socket.gethostname())
    return hostname

def getDBAndCollectionFromUrl(url):
    collection = None
    dbname = None
    if '/' in url:
        url, dbname = url.rsplit('/', 1)
    if '.' in dbname:
        dbname, collection = dbname.rsplit('.', 1)
    if dbname:
        url = '%s/%s' % (url, dbname)
    return url, dbname, collection

def encodeVigenere(key, clear):
    enc = []
    clear = str(clear).ljust(20, 'z')
    for i in range(len(clear)):
        key_c = key[i % len(key)]
        enc_c = chr((ord(clear[i]) + ord(key_c)) % 256)
        enc.append(enc_c)
    encStr = "".join(enc)
    return binascii.hexlify(encStr)

def decodeVigenere(key, enc):
    dec = []
    enc = binascii.unhexlify(str(enc))
    for i in range(len(enc)):
        key_c = key[i % len(key)]
        dec_c = chr((256 + ord(enc[i]) - ord(key_c)) % 256)
        dec.append(dec_c)
    return "".join(dec).rstrip('z')

def sub(regex, replStr, str):
    return re.sub(regex, replStr, str)

def setCORSAndCacheHeaders(request, response):
    # uncomment this if we want to enable any random domain
    log.debug("setCORSAndCacheHeaders: request.headers: [%s]" % str(request.headers))
    if 'Origin' in request.headers:
        originUrl = request.headers['Origin']
        # this header is also added from R2 config for *.ck12.org sites
        # the check is to prevent from adding it multiple times
        if "ck12.org" not in originUrl: 
            response.headers['Access-Control-Allow-Origin'] = originUrl
    if request.method == 'OPTIONS':
        # we want to return just the headers and not the complete response
        log.debug("OPTIONS call, returning only headers and no response")
        # cache the options call for 30 days
        response.headers['Access-Control-Max-Age'] = '2592000'
    
    if 'Access-Control-Request-Headers' in request.headers:
        response.headers['Access-Control-Allow-Headers'] = request.headers['Access-Control-Request-Headers']

    log.debug("setCORSAndCacheHeaders: response.headers: [%s]" % str(response.headers))
    setCacheControlHeaders(request, response)

def setCacheControlHeaders(request, response):
    cacheAgeMap = {
        "nocache" : 0,
        "quarter-hourly" : 60 * 15,
        "half-hourly" : 60 * 30,
        "hourly" : 3600,
        "daily" : 3600 * 24,
        "weekly" : 3600 * 24 * 7,
        "biweekly" : 3600 * 24 * 14,
        "monthly" : 3600 * 24 * 30,
        "yearly" : 3600 * 24 * 365
    }
    cacheAge = cacheAgeMap["nocache"]
    
    if 'expirationAge' in request.params:
        expirationAge = request.params.get('expirationAge')

        if request.method == 'OPTIONS':
            expirationAge = "monthly"
        if expirationAge in cacheAgeMap:
            cacheAge = cacheAgeMap[expirationAge]
        else:
            #this should not happen, error in the request
            pass

    ## Removing existing Cache-Control header, if present
    for header in ['Cache-Control', 'Pragma']:
        if header in response.headers:
            del response.headers[header]
    response.cache_expires(seconds=cacheAge)
    log.debug("setCacheControlHeaders: response.headers: [%s]" % str(response.headers))

def setSEOHeaders(response):
    response.headers['X-Robots-Tag'] = 'noindex'

def toJson(pythonObject):
    if isinstance(pythonObject, datetime):
        pythonObject = pythonObject.replace(tzinfo=Local)
        #return pythonObject.isoformat(' ')
        return pythonObject.isoformat()

    if isinstance(pythonObject, date):
        return pythonObject.isoformat()

    if isinstance(pythonObject, tm):
        return pythonObject.isoformat()

    if isinstance(pythonObject, Decimal):
        return pythonObject.isoformat()

    raise TypeError(repr(pythonObject) + ' is not JSON serializable')

def getExtSiteName(site):
    if not site:
        return ""
    if site.lower() == 'edmodoconnect':
        return "Edmodo"
    elif site.lower() == 'google':
        return "Google"
    elif site.lower() == 'twitter':
        return "Twitter"
    elif site.lower() == 'live':
        return "Microsoft"
    elif site.lower() == 'clever':
        return "Clever"
    elif site.lower() == 'classlink':
        return "ClassLink"
    else:
        return site

