import os, logging, hashlib, zlib
from sqlalchemy import desc, func
from paste.deploy.converters import asbool
from pylons import config
from flx.lib import helpers as h

log = logging.getLogger(__name__)

# [NOTE]: config.get() will ONLY read development.ini correctly if the process
#         goes through ``websetup`` (`paster setup-app`). In a plain stand-alone
#         Python process, cofig.get('vcs_mysql') will always return None and
#         imply using Bazaar.
#
# [TODO]: Remove Bazaar case once MySQL-based VCS is working.
#         
if not config.get('vcs_mysql'):
    config = h.load_pylons_config()
log.info("vcs_mysql: %s" % str(config.get('vcs_mysql')))
if not asbool(config.get('vcs_mysql')):
    # Use Bazaar
    from flx.lib.vcs.vcs import vcs
else:
    # Use MySQL
    from flx.model.model import ContentRevision, Content 
    from flx.model import meta
    class vcs:
        """
        The convention for path-related variables used in this class:
            `pathPrefix` : VCS home directory specified in property
            `basedir`    : Bucket directory path generated by hashing member ID (relative to `pathPrefix`)
            `relPath`    : Path relative to `basedir`
            `osPath`     : Absolute path to the file, i.e. `pathPrefix`/`basedir`/`relPath`/...
                           Paths in `newFiles`, `modFiles`, `delFiles`, and `newDirs` are of `osPath` types.
        """
        
        CONTENT_EXTENSION = '.xhtml'
        ADD, COMMIT, GET, GET_SIZE, GET_HISTORY, GET_REVISION, HAS_CHANGED, MKDIR, MKDIRS, REMOVE, REVERT, SAVE = range(12)
    
        def __init__(self, memberID, pathPrefix=None, inPlace=False, session=None):
            """
            All files belonging to member with memberID will be located
            under the directory of memberID.
    
            if inPlace is True, everything will be performed in place;
            otherwise, the task to communicate with the VCS will be
            done by another thread, synchronously. This is for VCS that
            are not thread-safe so that only 1 thread will be dedicated
            to perform the task.
            """
            self.memberID = memberID
            self.session = session if session else meta.Session()
            self.pathPrefix = pathPrefix or config.get('vcs_dir') or '/opt/data/bzr'
            self.newFiles = []
            self.modFiles = []
            self.delFiles = []  # files or directories
            self.newDirs = []
            self.rev = None
            self.noCache = asbool(config.get('vcs_nocache', True))  # default to no local file cache (i.e. read from db each time)
    
            self.basedir = ''  # need to be empty before self.makedirs(basedir)
            basedir = h.getBucketPath('', id=memberID)
            self.makedirs(basedir)
            self.basedir = basedir
            log.info('memberID: %s, basedir: %s, noCache: %s', memberID, self.basedir, self.noCache)
    
        def isSaved(self, relPath):
            path = os.path.join(self.basedir, relPath)
            path = self.__setFileExtension(path)
            osPath = os.path.join(self.pathPrefix, path)
            return osPath in self.newFiles or osPath in self.modFiles

        def save(self, relPath, contents=None, toInclude=True, cached=False):
            """Save contents into the file specified in relPath."""
            log.info('vcs.save relPath: %s', relPath)
            if contents is not None:
                path = os.path.join(self.basedir, relPath)
            else:
                # Contents uploaded, relPath is actually an absolute path to the file. 
                if not cached:
                    contents = h.getUploadedContents(relPath)
                path = os.path.join(self.basedir, relPath.filename.lstrip(os.sep))
            path = self.__setFileExtension(path)
    
            try:
                osPath = os.path.join(self.pathPrefix, path)
                if not cached:
                    h.saveContents(osPath, contents)
    
                log.debug('vcs.save: osPath[%s] self.newFiles[%s] self.modFiles[%s]' % (osPath, self.newFiles, self.modFiles))
                if toInclude and osPath not in self.newFiles and osPath not in self.modFiles:
                    self.modFiles.append(osPath)
                    self.__newRevision()

                log.debug('vcs.save: self.rev[%s]' % self.rev)
                return self.rev.id if self.rev else None
            except Exception, e:
                log.error('save: failed: %s', e)
                raise e
    
        def update(self, relPath, revNo=None, contents=None, toInclude=True, cached=False):
            """Update contents of the specified revision specified in relPath.
            
            If revNo is not specified, this is equivalent to save(). Otherwise,
            the revision is updated in place in db and no new revision is assigned.
            """
            log.info('relPath: %s; revNo: %s', relPath, revNo)
            if revNo is None:
                return self.save(relPath, contents, toInclude, cached)
            
            if contents is None:
                # Contents uploaded, relPath is actually an absolute path to the file. 
                contents = h.getUploadedContents(relPath)
    
            try:
                key = self.__getKey(self.__setFileExtension(relPath))
                rev = self.session.query(Content) \
                                  .filter(Content.resourceURI == key) \
                                  .filter(Content.contentRevisionID == revNo) \
                                  .filter(Content.ownerID == self.memberID) \
                                  .one()
                md5 = hashlib.md5()
                md5.update(contents)
                rev.checksum = md5.hexdigest()
                rev.contents = zlib.compress(contents)
                rev.compressed = True
                self.session.add(rev)
                self.session.flush()
            except Exception, e:
                log.error('Update failed: %s', e)
                raise e
    
        def add(self, relPath, contents=None):
            """Add a new file, optionally with contents."""
            log.info('add: member: %s, basedir: %s, relPath: %s', self.memberID, self.basedir, relPath)
            
            relPath = self.__setFileExtension(relPath)
            if not self.exists(relPath):
                if contents is not None:
                    self.save(relPath, contents=contents, toInclude=False)
                    osPath = os.path.join(self.pathPrefix, self.basedir, relPath)
                    if osPath not in self.newFiles:
                        self.newFiles.append(osPath)
            self.__newRevision()
            return self.rev.id
    
        def exists(self, relPath):
            """Check if the file exists."""
            key = self.__getKey(relPath)
            count = self.session.query(func.count(Content.contents)) \
                                .filter(Content.resourceURI == key) \
                                .filter(Content.ownerID == self.memberID) \
                                .scalar()
            log.debug('exists: key: %s, count: %s', key, count)
            return count > 0
    
        def get(self, relPath, revNo=None, useFile=True):
            """
            Get the contents of the given file, with the optional revision.
            If revision is not given, the latest will be used.
            """
            relPath = self.__setFileExtension(relPath)
            osPath = os.path.join(self.pathPrefix, self.basedir, relPath)
            log.info('vcs.get: Path[%s] revNo[%s] useFile[%s]' % (osPath, revNo, useFile))
            if not revNo and useFile and not self.noCache:
                try:
                    file = open(osPath, 'r')
                except Exception:
                    file = None
                if file is not None:
                    try:
                        contents = file.read()
                        return contents
                    finally:
                        file.close()
    
            key = self.__getKey(osPath)
            log.info('vcs.get: resourceURI[%s] ownerID[%s] revNo[%s]' % (key, self.memberID, revNo))
            if revNo:
                c = self.session.query(Content) \
                                    .filter(Content.resourceURI == key) \
                                    .filter(Content.ownerID == self.memberID) \
                                    .filter(Content.contentRevisionID == revNo) \
                                    .scalar()
                if not c:
                    c = self.session.query(Content) \
                                        .filter(Content.resourceURI == key) \
                                        .filter(Content.ownerID == self.memberID) \
                                        .order_by(desc(Content.contentRevisionID)) \
                                        .limit(1) \
                                        .offset(int(revNo) - 1) \
                                        .scalar()
            else:
                c = self.session.query(Content) \
                                    .filter(Content.resourceURI == key) \
                                    .filter(Content.ownerID == self.memberID) \
                                    .order_by(desc(Content.contentRevisionID)) \
                                    .limit(1) \
                                    .scalar()
            if not c:
                log.info('vcs.get: Content entry not found')
                return None

            if c.compressed:
                content = zlib.decompress(c.contents)
            else:
                content = c.contents
            log.info('vcs.get: len(content)[%s]' % len(content))
            return content

        def getSize(self, relPath, revNo=None):
            """
            Get the size of the given file with the optional revision.
            If revision is not given, the latest will be used.
            """
            return len(self.get(relPath, revNo))
    
        def getHistory(self, relPath, revNo=None):
            """
            Get the history of the given file with the optional revision.
            If revision is not given, the latest will be used.
            """
            key = self.__getKey(relPath)
            return [[obj.id, obj.creationTime, obj.log] for obj in
                        self.session.query(ContentRevision)
                                    .join(Content)
                                    .filter(Content.resourceURI == key)
                                    .filter(Content.ownerID == self.memberID)
                                    .order_by(desc(ContentRevision.creationTime))
                                    .all()]
    
        def getRevision(self, relPath):
            """Get the current revision info of the given file."""
            key = self.__getKey(relPath)
            revision = self.session.query(Content.contentRevisionID) \
                                   .filter(Content.resourceURI == key) \
                                   .filter(Content.ownerID == self.memberID) \
                                   .order_by(desc(Content.contentRevisionID)) \
                                   .limit(1) \
                                   .scalar()
            log.info('revision: %s', revision)
            return revision
    
        def hasChanged(self, relPath, contents=None):
            """Return True if the given file has uncommitted changes."""
            if relPath is None:
                return False

            relPath = self.__setFileExtension(relPath)
            if contents is not None:
                path = os.path.join(self.basedir, relPath)
            else:
                # Contents uploaded, relPath is actually an absolute path to the file. 
                contents = h.getUploadedContents(relPath)
                path = os.path.join(self.basedir, relPath.filename.lstrip(os.sep))

            osPath = os.path.join(self.pathPrefix, path)
            try:
                h.saveContents(osPath, contents)

                md5 = hashlib.md5()
                md5.update(open(osPath).read())
                localChecksum = md5.hexdigest() 

                key = self.__getKey(relPath)
                log.info('Content.resourceURI: [%s], Content.ownerID: [%s], ' %(key, self.memberID))
                dbChecksum = self.session.query(Content.checksum) \
                                        .filter(Content.resourceURI == key) \
                                        .filter(Content.ownerID == self.memberID) \
                                        .order_by(desc(Content.contentRevisionID)) \
                                        .limit(1) \
                                        .scalar()
                log.debug('db checksum: %s; local check sum: %s', dbChecksum, localChecksum)
                return localChecksum != dbChecksum
            except Exception, e:
                log.error('hasChanged: failed: %s', e)
                raise e
    
        def commit(self, message):
            """Commit all the changes."""
            if not (self.newFiles or self.modFiles or self.delFiles):
                return self.rev.id if self.rev else None
    
            log.info('new: %s; mod: %s; del: %s; message: %s', self.newFiles, self.modFiles, self.delFiles, message)
            try:
                self.__newRevision()
                self.rev.message = message
                
                files = self.newFiles + self.modFiles
                filesDict = {}
                for f in files:  # absolute paths
                    if filesDict.get(f):
                        continue
                    contents = open(f).read()
                    md5 = hashlib.md5()
                    md5.update(contents)
                    checksum = md5.hexdigest()
                    log.info('vcs.commit: len(contents)[%s]' % len(contents))
                    contents = zlib.compress(contents)
                    c = Content(resourceURI=self.__getKey(f),
                                ownerID=self.memberID,
                                contentRevisionID=self.rev.id,
                                contents=contents,
                                checksum=checksum,
                                compressed=True)
                    self.session.add(c)
                    filesDict[f] = c
    
                for f in self.delFiles:  # absolute paths
                    if os.path.isdir(f):
                        os.rmdir(f)
                    elif os.path.exists(f):
                        os.remove(f)
                
                self.newFiles = []
                self.modFiles = []
                self.delFiles = []
                self.newDirs = []
                revID = self.rev.id
                self.rev = None
                return revID
            except Exception, e:
                log.exception('Failed: commit: %s', e)
                self.revert()
                raise e
    
        def mkdir(self, relPath):
            """Create a directory."""
            osPath = os.path.join(self.pathPrefix, self.basedir, relPath)
    
            try:
                if not os.path.exists(osPath):
                    os.mkdir(osPath)
                    self.newDirs.append(osPath)
            except Exception, e:
                log.error('Failed: mkdir: %s', e)
                raise e
    
        def makedirs(self, relPath, commit=False, message=None):
            """Create all non-existent directories on the path (i.e. mkdir -p)."""
            relPath = os.path.dirname(relPath)
            path = os.path.join(self.basedir, relPath)
    
            try:
                dirPath = ''
                dirList = path.split(os.path.sep)
                for dir in dirList:
                    dirPath = os.path.join(dirPath, dir)
                    osPath = os.path.join(self.pathPrefix, dirPath)
                    if not os.path.exists(osPath):
                        os.mkdir(osPath)
                        self.newDirs.append(osPath)
            except Exception, e:
                log.error('Failed: makedirs: %s', e)
                raise e
    
        def remove(self, relPath, isDir=False):
            """Remove the given directory or file."""
            if not isDir:
                relPath = self.__setFileExtension(relPath)
            osPath = os.path.join(self.pathPrefix, self.basedir, relPath)
    
            self.delFiles.append(osPath)    # removal deferred till commit time
            key = self.__getKey(relPath)
            self.session.query(Content).filter(Content.resourceURI == key).filter(Content.ownerID == self.memberID).delete()
    
        def revert(self):
            """Forget all the uncommitted changes."""
            if len(self.newFiles) == 0 and len(self.modFiles) == 0 and len(self.newDirs) == 0:
                return None

            try:
                log.info('Roll back modified files: %s', self.modFiles)
                for f in self.modFiles:
                    key = self.__getKey(f)
                    c = self.session.query(Content) \
                                    .filter(Content.resourceURI == key) \
                                    .filter(Content.ownerID == self.memberID) \
                                    .order_by(desc(Content.contentRevisionID)) \
                                    .limit(1) \
                                    .scalar()
                    if c.compressed:
                        content = zlib.decompress(c.contents)
                    else:
                        content = c.contents
                    fd = open(f, 'w')
                    fd.write(content)
                    fd.close()
            except Exception, e:
                log.info('revert: %s', e)
            finally:
                log.info('Remove new files: %s', self.newFiles)
                for f in self.newFiles:
                    os.remove(f)

                log.info('Remove new directories: %s', self.newDirs)
                self.newDirs.reverse()
                for d in self.newDirs:
                    os.rmdir(d)
                    
                self.newFiles = []
                self.modFiles = []
                self.delFiles = []
                self.newDirs = []
                self.rev = None

            return None
    
        def __setFileExtension(self, path):
            return path #if path.endswith(self.CONTENT_EXTENSION) else (path + self.CONTENT_EXTENSION)
    
        def __getKey(self, path):
            """Get key for the given file."""
            return os.path.basename(path)
    
        def __newRevision(self):
            """Generate a new revision."""
            if not self.rev:
                self.rev = ContentRevision(log='')
                self.session.add(self.rev)
                self.session.flush()  # to force generating new rev.id
